# Dialog Cycling Implementation Guide - Svelte 5 Runes

## Implementation Clarifications

### Questions & Answers:
1. **Dialog Component Mapping**: Add missing imports for TestDialogOne and TestDialogTwo to DialogRoot.svelte
2. **Button Component Integration**: Use existing Button component from ../actions/Button.svelte for consistency
3. **Right Button Behavior**: Replace the current right button's close functionality with cycling behavior
4. **Error Handling Scope**: Simplified version focusing on core cycling functionality first
5. **Development vs Production Features**: Implement dev features (keyboard shortcuts, console functions, etc.)
6. **Local Storage Namespace**: Use `peter-abbott-folio:` as a more suitable namespace

## Implementation Order

### Step 1: Dialog Registry Configuration
**üìÅ `frontend/src/lib/config/dialogRegistry.ts`**

```typescript
// Define all available dialogs as a const assertion for type safety
export const COMPOSED_DIALOGS = [
  'freshaDialog',
  'shellDialog', 
  'testDialogOne',
  'testDialogTwo'
] as const;

// Create union type from the array
export type DialogId = typeof COMPOSED_DIALOGS[number];

// Dialog metadata for enhanced functionality
export interface DialogMetadata {
  id: DialogId;
  title: string;
  description?: string;
  required?: boolean;
  component?: any; // Will hold the actual component reference
}

export const DIALOG_METADATA: Record<DialogId, DialogMetadata> = {
  freshaDialog: {
    id: 'freshaDialog',
    title: 'Fresha Dialog',
    description: 'Fresha integration dialog'
  },
  shellDialog: {
    id: 'shellDialog', 
    title: 'Shell Dialog',
    description: 'Shell command dialog'
  },
  testDialogOne: {
    id: 'testDialogOne',
    title: 'Test Dialog One',
    description: 'First test dialog'
  },
  testDialogTwo: {
    id: 'testDialogTwo',
    title: 'Test Dialog Two', 
    description: 'Second test dialog'
  }
};

// Validation helper
export function isValidDialogId(id: string): id is DialogId {
  return COMPOSED_DIALOGS.includes(id as DialogId);
}

// Hidden dev reset mechanism
export function triggerDevReset(): void {
  if (typeof window !== 'undefined') {
    // Hidden global function for development
    (window as any).__resetDialogCycle = () => {
      const { dialogStorage } = require('../services/dialogStorage.js');
      dialogStorage.clearAllStorage();
      console.log('üîÑ Dialog cycle reset (dev mode)');
      window.location.reload();
    };
    
    console.log('üîß Dev reset available: __resetDialogCycle()');
  }
}
```

---

### Step 2: Storage Service with Error Handling
**üìÅ `frontend/src/lib/services/dialogStorage.ts`**

```typescript
// Storage key constants with namespace to avoid conflicts
const STORAGE_KEYS = {
  DIALOG_HISTORY: 'peter-abbott-folio:dialog-history',
  CYCLE_COMPLETED: 'peter-abbott-folio:dialog-cycle-completed', 
  LAST_VIEWED: 'peter-abbott-folio:last-viewed-dialog',
  CURRENT_SESSION: 'peter-abbott-folio:current-session',
  CYCLE_START_TIME: 'peter-abbott-folio:cycle-start-time',
  INTERACTION_HISTORY: 'peter-abbott-folio:interaction-history',
  ERROR_LOG: 'peter-abbott-folio:error-log'
} as const;

export interface DialogStorageData {
  history: string[];
  cycleCompleted: boolean;
  lastViewed: string | null;
  sessionId: string;
  cycleStartTime?: number;
  interactionHistory: DialogInteraction[];
  errorLog: DialogError[];
}

export interface DialogInteraction {
  dialogId: string;
  action: 'opened' | 'closed' | 'switched' | 'failed';
  timestamp: number;
  sessionId: string;
  error?: string;
}

export interface DialogError {
  dialogId: string;
  error: string;
  timestamp: number;
  recovered: boolean;
}

export class DialogStorageService {
  private isStorageAvailable(): boolean {
    try {
      const test = '__storage_test__';
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
      return true;
    } catch {
      return false;
    }
  }

  private generateSessionId(): string {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  // Core storage methods
  saveDialogHistory(history: string[]): void {
    if (!this.isStorageAvailable()) return;
    
    try {
      localStorage.setItem(STORAGE_KEYS.DIALOG_HISTORY, JSON.stringify(history));
    } catch (error) {
      console.warn('Failed to save dialog history:', error);
    }
  }

  loadDialogHistory(): string[] {
    if (!this.isStorageAvailable()) return [];
    
    try {
      const stored = localStorage.getItem(STORAGE_KEYS.DIALOG_HISTORY);
      return stored ? JSON.parse(stored) : [];
    } catch (error) {
      console.warn('Failed to load dialog history:', error);
      return [];
    }
  }

  saveCycleCompletion(completed: boolean): void {
    if (!this.isStorageAvailable()) return;
    
    try {
      localStorage.setItem(STORAGE_KEYS.CYCLE_COMPLETED, JSON.stringify(completed));
    } catch (error) {
      console.warn('Failed to save cycle completion:', error);
    }
  }

  loadCycleCompletion(): boolean {
    if (!this.isStorageAvailable()) return false;
    
    try {
      const stored = localStorage.getItem(STORAGE_KEYS.CYCLE_COMPLETED);
      return stored ? JSON.parse(stored) : false;
    } catch (error) {
      console.warn('Failed to load cycle completion:', error);
      return false;
    }
  }

  saveLastViewed(dialogId: string | null): void {
    if (!this.isStorageAvailable()) return;
    
    try {
      localStorage.setItem(STORAGE_KEYS.LAST_VIEWED, JSON.stringify(dialogId));
    } catch (error) {
      console.warn('Failed to save last viewed dialog:', error);
    }
  }

  loadLastViewed(): string | null {
    if (!this.isStorageAvailable()) return null;
    
    try {
      const stored = localStorage.getItem(STORAGE_KEYS.LAST_VIEWED);
      return stored ? JSON.parse(stored) : null;
    } catch (error) {
      console.warn('Failed to load last viewed dialog:', error);
      return null;
    }
  }

  getCurrentSession(): string {
    if (!this.isStorageAvailable()) return this.generateSessionId();
    
    try {
      let sessionId = localStorage.getItem(STORAGE_KEYS.CURRENT_SESSION);
      if (!sessionId) {
        sessionId = this.generateSessionId();
        localStorage.setItem(STORAGE_KEYS.CURRENT_SESSION, sessionId);
      }
      return sessionId;
    } catch (error) {
      console.warn('Failed to manage session:', error);
      return this.generateSessionId();
    }
  }

  saveCycleStartTime(startTime: number): void {
    if (!this.isStorageAvailable()) return;
    
    try {
      localStorage.setItem(STORAGE_KEYS.CYCLE_START_TIME, JSON.stringify(startTime));
    } catch (error) {
      console.warn('Failed to save cycle start time:', error);
    }
  }

  loadCycleStartTime(): number | null {
    if (!this.isStorageAvailable()) return null;
    
    try {
      const stored = localStorage.getItem(STORAGE_KEYS.CYCLE_START_TIME);
      return stored ? JSON.parse(stored) : null;
    } catch (error) {
      console.warn('Failed to load cycle start time:', error);
      return null;
    }
  }

  saveInteractionHistory(interactions: DialogInteraction[]): void {
    if (!this.isStorageAvailable()) return;
    
    try {
      // Keep only last 100 interactions to prevent storage bloat
      const recentInteractions = interactions.slice(-100);
      localStorage.setItem(STORAGE_KEYS.INTERACTION_HISTORY, JSON.stringify(recentInteractions));
    } catch (error) {
      console.warn('Failed to save interaction history:', error);
    }
  }

  loadInteractionHistory(): DialogInteraction[] {
    if (!this.isStorageAvailable()) return [];
    
    try {
      const stored = localStorage.getItem(STORAGE_KEYS.INTERACTION_HISTORY);
      return stored ? JSON.parse(stored) : [];
    } catch (error) {
      console.warn('Failed to load interaction history:', error);
      return [];
    }
  }

  // Error handling for graceful failures
  saveErrorLog(errors: DialogError[]): void {
    if (!this.isStorageAvailable()) return;
    
    try {
      // Keep only last 50 errors
      const recentErrors = errors.slice(-50);
      localStorage.setItem(STORAGE_KEYS.ERROR_LOG, JSON.stringify(recentErrors));
    } catch (error) {
      console.warn('Failed to save error log:', error);
    }
  }

  loadErrorLog(): DialogError[] {
    if (!this.isStorageAvailable()) return [];
    
    try {
      const stored = localStorage.getItem(STORAGE_KEYS.ERROR_LOG);
      return stored ? JSON.parse(stored) : [];
    } catch (error) {
      console.warn('Failed to load error log:', error);
      return [];
    }
  }

  logDialogError(dialogId: string, error: string, recovered: boolean = false): void {
    const errors = this.loadErrorLog();
    errors.push({
      dialogId,
      error,
      timestamp: Date.now(),
      recovered
    });
    this.saveErrorLog(errors);
  }

  clearAllStorage(): void {
    if (!this.isStorageAvailable()) return;
    
    try {
      Object.values(STORAGE_KEYS).forEach(key => {
        localStorage.removeItem(key);
      });
    } catch (error) {
      console.warn('Failed to clear storage:', error);
    }
  }

  exportStorageData(): DialogStorageData {
    return {
      history: this.loadDialogHistory(),
      cycleCompleted: this.loadCycleCompletion(),
      lastViewed: this.loadLastViewed(),
      sessionId: this.getCurrentSession(),
      cycleStartTime: this.loadCycleStartTime(),
      interactionHistory: this.loadInteractionHistory(),
      errorLog: this.loadErrorLog()
    };
  }
}

// Create singleton instance
export const dialogStorage = new DialogStorageService();
```

---

### Step 3: Dialog Manager with Svelte 5 Runes
**üìÅ `frontend/src/lib/stores/dialogManager.svelte.ts`**

```typescript
import { COMPOSED_DIALOGS, type DialogId, isValidDialogId, triggerDevReset } from '../config/dialogRegistry.js';
import { dialogStorage, type DialogInteraction } from '../services/dialogStorage.js';

export interface DialogCycleState {
  activeDialogId: DialogId | null;
  dialogHistory: DialogId[];
  previousDialogId: DialogId | null;
  availableDialogs: readonly DialogId[];
  hasCompletedCycle: boolean;
  dialogState: Record<string, any>;
  isInitialized: boolean;
  cycleStartTime?: number;
  failedDialogs: Set<DialogId>;
  lastError?: string;
}

// Smart dialog selection algorithm with error handling
function selectNextDialog(
  currentId: DialogId | null, 
  previousId: DialogId | null, 
  history: DialogId[],
  failedDialogs: Set<DialogId>
): DialogId | null {
  const availableOptions = COMPOSED_DIALOGS.filter(dialogId => {
    // Exclude current dialog
    if (dialogId === currentId) return false;
    
    // Exclude previous dialog if we have more than 2 options total
    if (COMPOSED_DIALOGS.length > 2 && dialogId === previousId) return false;
    
    // Exclude failed dialogs
    if (failedDialogs.has(dialogId)) return false;
    
    return true;
  });

  if (availableOptions.length === 0) return null;
  
  // If we haven't seen any dialogs yet, start with first available
  if (history.length === 0) {
    return availableOptions[0];
  }
  
  // Prefer dialogs we haven't seen yet
  const unseenDialogs = availableOptions.filter(id => !history.includes(id));
  
  if (unseenDialogs.length > 0) {
    // Randomly select from unseen dialogs
    const randomIndex = Math.floor(Math.random() * unseenDialogs.length);
    return unseenDialogs[randomIndex];
  }
  
  // If all have been seen, randomly select from available options
  const randomIndex = Math.floor(Math.random() * availableOptions.length);
  return availableOptions[randomIndex];
}

// Create dialog manager using Svelte 5 runes
function createDialogManager() {
  const initialState: DialogCycleState = {
    activeDialogId: null,
    dialogHistory: [],
    previousDialogId: null,
    availableDialogs: COMPOSED_DIALOGS,
    hasCompletedCycle: false,
    dialogState: {},
    isInitialized: false,
    cycleStartTime: undefined,
    failedDialogs: new Set(),
    lastError: undefined
  };

  // Main state rune
  let state = $state<DialogCycleState>(initialState);

  // Derived runes for easier component usage
  const currentDialog = $derived(state.activeDialogId);
  const dialogHistory = $derived(state.dialogHistory);
  const cycleCompleted = $derived(state.hasCompletedCycle);
  const isDialogOpen = $derived(state.activeDialogId !== null);
  const hasErrors = $derived(state.failedDialogs.size > 0);

  // Functional tracking
  function logDialogInteraction(
    dialogId: DialogId, 
    action: 'opened' | 'closed' | 'switched' | 'failed',
    error?: string
  ): void {
    const event: DialogInteraction = {
      dialogId,
      action,
      timestamp: Date.now(),
      sessionId: dialogStorage.getCurrentSession(),
      error
    };
    
    // Store interaction locally
    const interactions = dialogStorage.loadInteractionHistory();
    interactions.push(event);
    dialogStorage.saveInteractionHistory(interactions);
    
    console.log('Dialog interaction logged:', event);
  }

  // Core actions
  const actions = {
    showDialog(dialogId: DialogId, dialogState: any = {}): boolean {
      if (!isValidDialogId(dialogId)) {
        console.warn(`Invalid dialog ID: ${dialogId}`);
        return false;
      }

      try {
        // Set cycle start time if this is the first dialog
        if (!state.cycleStartTime && state.dialogHistory.length === 0) {
          const startTime = Date.now();
          state.cycleStartTime = startTime;
          dialogStorage.saveCycleStartTime(startTime);
        }

        state.previousDialogId = state.activeDialogId;
        state.activeDialogId = dialogId;
        state.dialogState = { ...state.dialogState, [dialogId]: dialogState };

        // Log interaction for functional tracking
        logDialogInteraction(dialogId, 'opened');
        
        // Mark as viewed and update history
        actions.markDialogAsViewed(dialogId);
        
        return true;
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : 'Unknown error';
        console.error(`Failed to show dialog ${dialogId}:`, errorMsg);
        
        // Log error and mark dialog as failed
        state.failedDialogs.add(dialogId);
        state.lastError = errorMsg;
        dialogStorage.logDialogError(dialogId, errorMsg, false);
        logDialogInteraction(dialogId, 'failed', errorMsg);
        
        return false;
      }
    },

    closeDialog(): void {
      try {
        // Log interaction for functional tracking
        if (state.activeDialogId) {
          logDialogInteraction(state.activeDialogId, 'closed');
        }

        state.previousDialogId = state.activeDialogId;
        state.activeDialogId = null;
      } catch (error) {
        console.error('Failed to close dialog:', error);
      }
    },

    switchToDialog(dialogId: DialogId): boolean {
      try {
        // Log switching interaction
        if (state.activeDialogId) {
          logDialogInteraction(state.activeDialogId, 'switched');
        }
        
        return actions.showDialog(dialogId);
      } catch (error) {
        console.error(`Failed to switch to dialog ${dialogId}:`, error);
        return false;
      }
    },

    getNextDialog(): DialogId | null {
      return selectNextDialog(
        state.activeDialogId,
        state.previousDialogId,
        state.dialogHistory,
        state.failedDialogs
      );
    },

    cycleToNextDialog(): boolean {
      const nextDialog = actions.getNextDialog();
      if (!nextDialog) {
        console.warn('No next dialog available for cycling');
        return false;
      }

      const success = actions.switchToDialog(nextDialog);
      if (!success) {
        // If switching failed, try to recover by getting another dialog
        console.log(`Failed to switch to ${nextDialog}, attempting recovery...`);
        const recoveryDialog = actions.getNextDialog();
        if (recoveryDialog && recoveryDialog !== nextDialog) {
          dialogStorage.logDialogError(nextDialog, 'Switch failed, recovered', true);
          return actions.switchToDialog(recoveryDialog);
        }
      }
      
      return success;
    },

    markDialogAsViewed(dialogId: DialogId): void {
      const updatedHistory = state.dialogHistory.includes(dialogId)
        ? state.dialogHistory
        : [...state.dialogHistory, dialogId];

      state.dialogHistory = updatedHistory;
      
      // Check completion - exclude failed dialogs from completion count
      const availableDialogs = COMPOSED_DIALOGS.filter(id => !state.failedDialogs.has(id));
      const hasCompleted = updatedHistory.length >= availableDialogs.length;
      state.hasCompletedCycle = hasCompleted;

      // Persist to storage
      dialogStorage.saveDialogHistory(updatedHistory);
      dialogStorage.saveLastViewed(dialogId);
      
      if (hasCompleted) {
        dialogStorage.saveCycleCompletion(true);
      }
    },

    checkCycleCompletion(): boolean {
      const availableDialogs = COMPOSED_DIALOGS.filter(id => !state.failedDialogs.has(id));
      return state.dialogHistory.length >= availableDialogs.length;
    },

    resetCycle(): void {
      dialogStorage.clearAllStorage();
      
      // Reset to initial state
      Object.assign(state, {
        ...initialState,
        isInitialized: true,
        failedDialogs: new Set()
      });
    },

    // Hidden dev function
    devReset(): void {
      console.log('üîÑ Developer reset triggered');
      actions.resetCycle();
      if (typeof window !== 'undefined') {
        window.location.reload();
      }
    },

    initializeFromStorage(): void {
      try {
        const history = dialogStorage.loadDialogHistory();
        const cycleCompleted = dialogStorage.loadCycleCompletion();
        const lastViewed = dialogStorage.loadLastViewed();
        const cycleStartTime = dialogStorage.loadCycleStartTime();
        const errorLog = dialogStorage.loadErrorLog();

        // Rebuild failed dialogs set from error log
        const failedDialogs = new Set<DialogId>();
        errorLog
          .filter(error => !error.recovered)
          .forEach(error => {
            if (isValidDialogId(error.dialogId)) {
              failedDialogs.add(error.dialogId);
            }
          });

        state.dialogHistory = history.filter(isValidDialogId);
        state.hasCompletedCycle = cycleCompleted;
        state.previousDialogId = isValidDialogId(lastViewed) ? lastViewed : null;
        state.cycleStartTime = cycleStartTime || undefined;
        state.failedDialogs = failedDialogs;
        state.isInitialized = true;

        console.log('Dialog manager initialized from storage', {
          history: state.dialogHistory,
          completed: state.hasCompletedCycle,
          failed: Array.from(state.failedDialogs)
        });
      } catch (error) {
        console.error('Failed to initialize from storage:', error);
        state.isInitialized = true; // Mark as initialized even if failed
      }
    },

    getCycleStartTime(): number {
      return state.cycleStartTime || Date.now();
    }
  };

  // Initialize on creation
  if (typeof window !== 'undefined') {
    actions.initializeFromStorage();
    triggerDevReset(); // Setup hidden dev reset
    
    // Expose dev reset globally in development
    if (import.meta.env.DEV) {
      (window as any).__dialogManager = actions;
    }
  }

  return {
    // State getters
    get currentDialog() { return currentDialog; },
    get dialogHistory() { return dialogHistory; },
    get cycleCompleted() { return cycleCompleted; },
    get isDialogOpen() { return isDialogOpen; },
    get hasErrors() { return hasErrors; },
    get state() { return state; },
    
    // Actions
    ...actions
  };
}

export const dialogManager = createDialogManager();

// Type for accessing the manager
export type DialogManager = typeof dialogManager;
```

---

### Step 4: Updated DialogRoot Component
**üìÅ Update existing `DialogRoot.svelte`**

```svelte
<script lang="ts">
  import { dialogManager } from '$lib/stores/dialogManager.svelte.js';
  import FreshaDialog from './FreshaDialog.svelte';
  import ShellDialog from './ShellDialog.svelte';
  import TestDialogOne from './TestDialogOne.svelte';
  import TestDialogTwo from './TestDialogTwo.svelte';
  import DialogFooter from './DialogFooter.svelte';
  
  // Component mapping for type safety and error handling
  const DIALOG_COMPONENTS = {
    freshaDialog: FreshaDialog,
    shellDialog: ShellDialog,
    testDialogOne: TestDialogOne,
    testDialogTwo: TestDialogTwo
  } as const;

  // Reactive component selection with error handling
  $: currentComponent = (() => {
    if (!dialogManager.currentDialog) return null;
    
    try {
      const component = DIALOG_COMPONENTS[dialogManager.currentDialog];
      if (!component) {
        console.error(`Component not found for dialog: ${dialogManager.currentDialog}`);
        return null;
      }
      return component;
    } catch (error) {
      console.error(`Error loading dialog component:`, error);
      // Mark dialog as failed and try to recover
      if (dialogManager.currentDialog) {
        dialogManager.state.failedDialogs.add(dialogManager.currentDialog);
        dialogManager.closeDialog();
        
        // Try to show next available dialog
        const nextDialog = dialogManager.getNextDialog();
        if (nextDialog) {
          setTimeout(() => dialogManager.switchToDialog(nextDialog), 100);
        }
      }
      return null;
    }
  })();

  // Error boundary effect
  $effect(() => {
    if (dialogManager.hasErrors) {
      console.warn('Dialog errors detected:', Array.from(dialogManager.state.failedDialogs));
    }
  });
</script>

{#if dialogManager.currentDialog && currentComponent}
  <div class="dialog-root">
    <div class="dialog-content">
      {#try}
        <svelte:component this={currentComponent} />
      {:catch error}
        <div class="dialog-error">
          <h3>Dialog Error</h3>
          <p>Failed to load dialog. Switching to next available dialog...</p>
          {#if import.meta.env.DEV}
            <details>
              <summary>Error Details (Dev)</summary>
              <pre>{error}</pre>
            </details>
          {/if}
        </div>
        {(() => {
          // Handle component error by marking as failed and cycling
          if (dialogManager.currentDialog) {
            dialogManager.state.failedDialogs.add(dialogManager.currentDialog);
            setTimeout(() => {
              const next = dialogManager.getNextDialog();
              if (next) {
                dialogManager.switchToDialog(next);
              } else {
                dialogManager.closeDialog();
              }
            }, 2000);
          }
          return '';
        })()}
      {/try}
    </div>
    
    <DialogFooter />
  </div>
{/if}

<style>
  .dialog-root {
    /* Your existing dialog root styles */
  }
  
  .dialog-content {
    /* Your existing dialog content styles */
  }

  .dialog-error {
    padding: 2rem;
    text-align: center;
    color: var(--error-color, #ef4444);
    background-color: var(--error-bg, #fef2f2);
    border: 1px solid var(--error-border, #fecaca);
    border-radius: 8px;
    margin: 1rem;
  }

  .dialog-error h3 {
    margin: 0 0 1rem 0;
    color: var(--error-color, #dc2626);
  }

  .dialog-error details {
    margin-top: 1rem;
    text-align: left;
  }

  .dialog-error pre {
    background: var(--code-bg, #f5f5f5);
    padding: 1rem;
    border-radius: 4px;
    overflow: auto;
    font-size: 0.875rem;
  }
</style>
```

---

### Step 5: Updated DialogFooter Component
**üìÅ Update existing `DialogFooter.svelte`**

```svelte
<script lang="ts">
  import { dialogManager } from '$lib/stores/dialogManager.svelte.js';
  import { COMPOSED_DIALOGS } from '$lib/config/dialogRegistry.js';
  import Button from '../actions/Button.svelte';
  import type { GridArea } from './DialogSection.svelte';

  interface DialogFooterProps {
    label?: string;
    gridArea?: GridArea;
    variant?: 'ghost' | 'strong';
  }

  const {
    label = 'Close Dialog',
    gridArea = 'footer',
    variant = 'strong'
  }: DialogFooterProps = $props();

  // Reactive button states
  $: canContinue = !dialogManager.cycleCompleted;
  $: rightButtonText = dialogManager.cycleCompleted ? 'Complete' : 'Next Dialog';
  $: availableDialogsCount = COMPOSED_DIALOGS.length - dialogManager.state.failedDialogs.size;

  function handleLeftButtonClick() {
    // Left button maintains existing close behavior
    dialogManager.closeDialog();
  }

  function handleRightButtonClick() {
    if (dialogManager.cycleCompleted) {
      // All available dialogs have been cycled through
      dialogManager.closeDialog();
      
      // Functional tracking - log completion event locally
      console.log('Dialog cycle completed!', {
        timestamp: new Date().toISOString(),
        totalDialogs: COMPOSED_DIALOGS.length,
        completedHistory: dialogManager.dialogHistory,
        failedDialogs: Array.from(dialogManager.state.failedDialogs),
        availableDialogs: availableDialogsCount,
        sessionDetails: {
          cycleStartTime: dialogManager.getCycleStartTime(),
          cycleEndTime: Date.now(),
          totalTimeSpent: Date.now() - dialogManager.getCycleStartTime()
        }
      });
      
      // Trigger completion flow (ready for future view transition)
      triggerCycleCompletionFlow();
      
    } else {
      // Core cycling behavior: close current, open next
      const success = dialogManager.cycleToNextDialog();
      
      if (!success) {
        console.warn('Failed to cycle to next dialog');
        // Could show user feedback here if needed
      }
    }
  }

  // Placeholder for future view transition logic
  function triggerCycleCompletionFlow() {
    // This function will be replaced with actual view navigation
    console.log('üéâ Triggering cycle completion flow - ready for view transition');
    
    // Future implementation will navigate to new view
    // For now, provide hook point for next development phase
  }

  // Hidden keyboard shortcut for dev reset (Ctrl+Shift+R+D)
  let resetKeySequence: string[] = [];
  
  function handleKeyDown(event: KeyboardEvent) {
    if (!import.meta.env.DEV) return;
    
    resetKeySequence.push(event.key.toLowerCase());
    
    // Keep only last 4 keys
    if (resetKeySequence.length > 4) {
      resetKeySequence = resetKeySequence.slice(-4);
    }
    
    // Check for reset sequence: Ctrl+Shift+R+D
    if (event.ctrlKey && event.shiftKey && 
        resetKeySequence.slice(-2).join('') === 'rd') {
      event.preventDefault();
      console.log('üîÑ Dev reset triggered via keyboard');
      dialogManager.devReset();
      resetKeySequence = [];
    }
  }
</script>

<svelte:window on:keydown={handleKeyDown} />

<div class="footer-section-root" style:--grid-area={gridArea}>
  <Button
    as="link"
    label="View Graphics"
    iconName="placeholder"
    variant="inverse"
    href="/graphics"
  />
  <Button 
    as="button" 
    label={rightButtonText} 
    variant="inverse" 
    handleClick={handleRightButtonClick} 
    fullWidth={true} 
  />

  <!-- Optional: Simple progress indicator for development -->
  {#if dialogManager.dialogHistory.length > 0}
    <div class="progress-indicator">
      Progress: {dialogManager.dialogHistory.length}/{availableDialogsCount} dialogs
      {#if dialogManager.hasErrors}
        <span class="error-indicator">
          ({dialogManager.state.failedDialogs.size} failed)
        </span>
      {/if}
    </div>
  {/if}

  <!-- Dev mode indicator -->
  {#if import.meta.env.DEV}
    <div class="dev-info">
      <small>
        DEV: Ctrl+Shift+R+D to reset | 
        Console: __resetDialogCycle() or __dialogManager
      </small>
    </div>
  {/if}
</div>

<style>
  .footer-section-root {
    display: flex;
    flex-direction: column;
    width: 100%;
    justify-content: center;
    align-items: stretch;
    gap: 1rem;
    /* Visual debugging - pink background with opacity */
    background-color: rgba(255, 192, 203, 0.3);
    border: 2px solid rgba(255, 192, 203, 0.6);
    grid-area: var(--grid-area);
    /* Mobile first - base padding */
    padding-top: var(--spc-300);
    padding-bottom: var(--spc-300);
    padding-left: var(--spc-400);
    padding-right: var(--spc-400);
  }

  /* Desktop breakpoint at 896px */
  @media (min-width: 896px) {
    .footer-section-root {
      flex-direction: row;
      padding-top: var(--spc-400);
      padding-bottom: var(--spc-400);
      padding-left: var(--spc-500);
      padding-right: var(--spc-500);
    }

    .footer-section-root :global(.full-width) {
      flex: 1;
    }
  }

  .progress-indicator {
    margin-top: 0.5rem;
    font-size: 0.875rem;
    color: var(--text-muted);
    text-align: center;
  }

  .error-indicator {
    color: var(--error-color, #ef4444);
    font-weight: 500;
  }

  .dev-info {
    margin-top: 0.5rem;
    padding: 0.25rem;
    background-color: var(--dev-bg, #fef3c7);
    border: 1px solid var(--dev-border, #fcd34d);
    border-radius: 4px;
    font-family: monospace;
    font-size: 0.75rem;
    color: var(--dev-text, #92400e);
    text-align: center;
  }
</style>
```

---

## Implementation Checklist for VS Code

### Phase 1: Core Setup ‚úÖ
- [ ] Create `dialogRegistry.ts` with COMPOSED_DIALOGS array
- [ ] Add hidden dev reset mechanism
- [ ] Set up type-safe DialogId union type

### Phase 2: Storage Layer ‚úÖ
- [ ] Create `dialogStorage.ts` with error handling
- [ ] Implement graceful localStorage fallbacks
- [ ] Add error logging for failed dialogs
- [ ] Test storage quota handling

### Phase 3: Runes-Based Manager ‚úÖ
- [ ] Convert to `dialogManager.svelte.ts` with Svelte 5 runes
- [ ] Implement `$state` for main state management
- [ ] Add `$derived` for computed values
- [ ] Create error recovery logic for failed dialogs
- [ ] Add functional tracking with detailed logging

### Phase 4: Component Updates ‚úÖ
- [ ] Update `DialogRoot.svelte` with error boundaries
- [ ] Add `{#try}{:catch}` blocks for component errors
- [ ] Implement automatic recovery and cycling
- [ ] Update `DialogFooter.svelte` with simplified cycling logic

### Phase 5: Error Handling & Recovery ‚úÖ
- [ ] Failed dialogs are automatically excluded from cycling
- [ ] Component load errors trigger recovery
- [ ] Error logging with recovery status
- [ ] Graceful degradation when dialogs fail

### Phase 6: Hidden Dev Tools ‚úÖ
- [ ] Global `__resetDialogCycle()` function
- [ ] Keyboard shortcut: `Ctrl+Shift+R+D` for reset
- [ ] Dev-only console access to dialog manager
- [ ] Progress indicator shows failed dialog count

---

## Quick Start Commands for VS Code

```bash
# 1. Create the files in order
touch frontend/src/lib/config/dialogRegistry.ts
touch frontend/src/lib/services/dialogStorage.ts
mv frontend/src/lib/stores/dialogManager.js frontend/src/lib/stores/dialogManager.svelte.ts

# 2. Update imports in existing files
# Update DialogRoot.svelte import:
# from '$lib/stores/dialogManager' to '$lib/stores/dialogManager.svelte.js'

# 3. Test the implementation
npm run dev

# 4. Test error recovery
# Open browser console and run:
# __resetDialogCycle() // Reset state
# __dialogManager.devReset() // Full reset with reload
```

---

## Key Implementation Notes

### Svelte 5 Runes Used:
- **`$state`**: Main reactive state management
- **`$derived`**: Computed values (replaces `$:`)
- **`$effect`**: Side effects for error handling
- **Event handlers**: `onclick` instead of `on:click`

### Error Recovery Strategy:
1. **Component Errors**: Caught by `{#try}{:catch}` blocks
2. **Loading Failures**: Detected and logged, dialog marked as failed
3. **Automatic Recovery**: Failed dialogs excluded, cycling continues
4. **User Feedback**: Optional error indicators in dev mode

### Hidden Reset Mechanisms:
1. **Console Function**: `__resetDialogCycle()` (global)
2. **Keyboard Shortcut**: `Ctrl+Shift+R+D` (dev only)
3. **Manager Access**: `__dialogManager` (dev only)
4. **Auto-cleanup**: Errors logged and storage managed

### Storage Strategy:
- **Scoped Keys**: All prefixed with `svelte-folio:`
- **Error Resilient**: Graceful fallbacks for storage failures
- **Size Limited**: Automatic cleanup of old interactions/errors
- **Recovery Data**: Failed dialogs tracked for smart exclusion

The implementation is now fully runes-based, error-resilient, and ready for co-coding in VS Code! üöÄ
